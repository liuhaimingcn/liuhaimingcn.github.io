[{"title":"DNS Records 名词解释","date":"2017-04-04T16:00:00.000Z","path":"2017/04/05/Linux/dns-records/","text":"DNS Domain Name System 域名服务器 域名虽然便于人们记忆，但网络中的计算机之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS 就是进行域名解析的服务器。 A记录 A（Address）记录是用来指定域名对应的IP地址记录。 通俗来说A记录就是服务器的IP,域名绑定, A记录就是告诉DNS,当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器。 CNAME记录 CNAME（Canonical Name ）别名记录，允许您将多个名字映射到同一台计算机。 例如，有一台计算机名为 “host.mydomain.com”（A记录），它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL， 这两个别名的全称就“www.mydomain.com”和“mail.mydomain.com”，实际上他们都指向 “host.mydomain.com”。 NS记录 NS（Name Server）记录是域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析。 注册域名时，总有默认的DNS服务器，每个注册的域名都是由一个DNS域名服务器来进行解析的，DNS服务器NS记录地址一般以以下的形式出现： ns1.domain.com、ns2.domain.com等。 MX记录 MX（Mail Exchanger）记录是邮件交换记录，它指向一个邮件服务器，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器。 例如，当Internet上的某用户要发一封信给 user@mydomain.com 时，该用户的邮件系统通过DNS查找mydomain.com这个域名的MX记录，如果MX记录存在， 用户计算机就将邮件发送到MX记录所指定的邮件服务器上。 TXT记录 TXT记录，一般指某个主机名或域名的说明，如：Jim IN TXT “contact: abc@mailserver.com”，也就是您可以设置 TXT 内容以便使别人联系到您。 TXT的应用之一，SPF（Sender Policy Framework）反垃圾邮件。SPF是跟DNS相关的一项技术，它的内容写在DNS的TXT类型的记录里面。MX记录的作用是给寄信者指明某个域名的邮件服务器有哪些。SPF的作用跟MX相反，它向收信者表明，哪些邮件服务器是经过某个域名认可会发送邮件的。SPF的作用主要是反垃圾邮件，主要针对那些发信人伪造域名的垃圾邮件。例如：当邮件服务器收到自称发件人是spam@gmail.com的邮件，那么到底它是不是真的gmail.com的邮件服务器发过来的呢，我们可以查询gmail.com的SPF记录，以此防止别人伪造你来发邮件。 PTR值 PTR是pointer的简写，用于将一个IP地址映射到对应的域名，也可以看成是A记录的反向，IP地址的反向解析。 PTR主要用于邮件服务器，比如邮箱AAA@XXX.com给邮箱BBB@yahoo.com发了一封邮件，yahoo邮件服务器接到邮件时会查看这封邮件的头文件，并分析是由哪个IP地址发出来的，然后根据这个IP地址进行反向解析，如果解析结果对应XXX.com的IP地址就接受这封邮件，反之则拒绝接收这封邮件。 泛域名与泛解析 泛域名是指在一个域名根下，以 *.Domain.com的形式表示这个域名根所有未建立的子域名。 泛解析是把*.Domain.com的A记录解析到某个IP 地址上，通过访问任意的前缀.domain.com都能访问到你解析的站点上。 域名绑定 域名绑定是指将域名指向服务器IP的操作。 域名转向 域名转向又称为域名指向或域名转发，当用户地址栏中输入您的域名时，将会自动跳转到您所指定的另一个域名。一般是使用短的好记的域名转向复杂难记的域名。 TTL值 简单的说，TTL(Time-To-Live)就是一条域名解析记录在DNS服务器中的存留时间。当各地的DNS服务器接受到解析请求时，就会向域名指定的NS服务器发出解析请求从而获得解析记录；在获得这个记录之后，记录会在DNS服务器中保存一段时间，这段时间内如果再接到这个域名的解析请求，DNS服务器将不再向NS服务器发出请求，而是直接返回刚才获得的记录，而这个记录在DNS服务器上保留的时间，就是TTL值。 TTL值设置的应用： 一是增大TTL值，以节约域名解析时间，给网站访问加速。 一般情况下，域名的各种记录是极少更改的，很可能几个月、几年内都不会有什么变化。我们完全可以增大域名记录的TTL值让记录在各地DNS服务器中缓存的时间加长，这样在更长的一段时间内，我们访问这个网站时，本地ISP的DNS服务器就不需要向域名的NS服务器发出解析请求，而直接从缓存中返回域名解析记录。 二是减小TTL值，减少更换空间时的不可访问时间。 更换空间99.9%会有DNS记录更改的问题，因为缓存的问题，新的域名记录在有的地方可能生效了，但在有的地方可能等上一两天甚至更久才生效。结果就是有的人可能访问到了新服务器，有的人访问到了旧服务器。仅仅是访问的话，这也不是什么大问题，但如果涉及到了邮件发送，这个就有点麻烦了，说不定哪封重要信件就被发送到了那已经停掉的旧服务器上。 为了尽可能的减小这个各地的解析时间差，合理的做法是： 第一步，先查看域名当前的TTL值，我们假定是1天。 第二步，修改TTL值为可设定的最小值，可能的话，建议为1分钟，就是60。 第三步，等待一天，保证各地的DNS服务器缓存都过期并更新了记录。 第四步，设置修改新记录，这个时候各地的DNS就能以最快的速度更新到新的记录。 第五步，确认各地的DNS已经更新完成后，把TTL值设置成您想要的值。 参考文章 DNS记录类型介绍(A记录、MX记录、NS记录等)","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"理解 volatile","date":"2017-04-04T16:00:00.000Z","path":"2017/04/05/Java/volatile/","text":"Java内存模型 Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 i = 10; // 该赋值程序执行时线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题（一个线程修改数据没有及时写回主内存，另一个线程读取没修改的主内存数据，最终为主内存赋值时产生错误的结果）。 原子性 原子性是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 原子性经典的例子银行账户转账问题：比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。这2个操作必须要具备原子性才能保证不出现一些意外的问题。 在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 1234x = 10; // 原子性操作（直接将数值10赋值给x，线程执行这个语句时会直接将数值10写入到工作内存中。）y = x; // 非原子性操作（包含2个操作，它先要去读取x的值，再将x的值写入工作内存。）x++; // 非原子性操作（包括3个操作：读取x的值，进行加1操作，写入新的值。）x = x + 1; // 非原子性操作（包括3个操作：读取x的值，进行加1操作，写入新的值。） 可见性 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主内存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 12345678910// 可见性问题实例int i = 0;//线程1执行的代码i = 10;//线程2执行的代码j = i; // 线程2执行时，如果线程1执行了但是没有把结果立即写回到主内存当中，那么线程2读取i加载到工作内存的依然是0，此时线程2没有立即看到线程1修改的值。 有序性 有序性是指即程序执行的顺序按照代码的先后顺序执行。 1234567// 有序性实例int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2// 从代码顺序上看，语句1是在语句2前面的，但是此时可能会发生指令重排序（Instruction Reorder），因为语句1和语句2谁先执行对最终的程序结果并没有影响，JVM在真正执行这段代码的时候不会保证语句1一定会在语句2的前面。 指令重排序：一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 123456789101112// 指令重排序实例//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context);// 由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 理解volatile 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile不能确保原子性 volatile的实现原理 《深入理解Java虚拟机》中写道：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” 如果对声明了volatile的变量进行了写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在的缓存行的数据写回到系统内存。在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置为无效状态，重新从系统内存中把数据读到处理器缓存里。 Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。 volatile的应用场景 synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。 123456789101112131415161718192021222324252627// 状态标记量，根据状态标记，终止线程。volatile boolean flag = false;//线程1while(!flag)&#123; doSomething();&#125;//线程2public void setFlag() &#123; flag = true;&#125;// 单例模式中的double check，主要在于instance = new Singleton()这句，这并非是一个原子操作。class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 参考文章 你真的了解volatile关键字吗？","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"}]},{"title":"Linux调优","date":"2017-03-26T16:00:00.000Z","path":"2017/03/27/Linux/linux-kernel/","text":"打开文件数设置1234cat &gt;&gt; /etc/security/limits.conf &lt;&lt; EOF* soft nofile 65535* hard nofile 65535EOF Linux内核调优1234567891011121314cat &gt;&gt; /etc/sysctl.conf &lt;&lt; EOF# 该参数设置系统的TIME_WAIT的数量，如果超过默认值则会被立即清除net.ipv4.tcp_max_tw_buckets = 20000# 定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数net.core.somaxconn = 65535# 对于还未获得对方确认的连接请求，可保存在队列中的最大数目net.ipv4.tcp_max_syn_backlog = 262144# 在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目net.core.netdev_max_backlog = 30000# 能够更快地回收TIME-WAIT套接字。此选项会导致处于NAT网络的客户端超时，建议为0net.ipv4.tcp_tw_recycle = 0# 系统所有进程一共可以打开的文件数量fs.file-max = 6815744EOF","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"使用jenkins进行项目的自动构建部署","date":"2016-12-20T16:00:00.000Z","path":"2016/12/21/Architecture/jenkins/","text":"jenkins 简介 Jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作，功能包括：持续的软件版本发布/测试项目和监控外部调用执行的工作。 官网地址地址： https://jenkins.io 下载安装启动CentOS 下用yum进行安装启动123456789101112# 先更新源再安装最新版 jenkinssudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.keysudo yum install jenkins# 启动sudo service jenkins start# 停止sudo service jenkins stop# 重启sudo service jenkins restart# 检查sudo chkconfig jenkins on 下载war包放到tomcat中启动 服务器 yum 安装速度太慢了，最终我选择了这种方式，本地下载好war包传到服务器上的tomcat容器下，然后启动 下载地址：http://mirrors.jenkins.io/war-stable/latest/jenkins.war 初始化 在浏览器中输入url打开jenkins的后台控制页面 初始化成功后会自动生成一个管理员密码放到指定位置，根据页面提示复制密码粘贴到输入框就可以登录了 登录成功后回让你选择插件的安装，可以选择建议的安装也可以自己进行选择，不清楚的话可以使用建议的安装 由于建议安装的插件比较多，安装的过程有点慢，多等待一会 安装的过程也可能因为网络等一些原因安装会失败，现在可以无视它，点击Continue，后面再进行手动的安装 安装完成后最好新创建一个管理员账户代替之前的临时自动生成的密码账户 初始化完成，进入后台管理界面 安装插件 之前初始化的时候，有些插件安装失败，可以在用到的时候来手动修复它，没用到的话就可以暂且不理它，不影响jenkins的使用 点击左侧边栏的“系统管理”，就可以看了插件安装的一些错误信息 在“系统管理”中往下拉,找到“管理插件”点击进去就可以查看和管理所有的插件，点击“可选插件”显示所有jenkins支持的插件，在右上角的“过滤”输入框中，输入需要安装的插件名就可以筛选查找到想要的插件 选中要安装的插件输入框，点击安装就可以在线安装需要的插件，当然由于网络的原因也可能再次安装错误，或者安装的比较慢。我们可以点击插件名进入插件的主页，里面有该插件的详细信息并能下载hpi文件进行手动安装 在“管理插件”的页面中点击高级选项，我们可以在下面找到“上传插件”，上传下载好的插件，点击“上传”，系统就会自动上传安装该插件。 gitlab的配置 集成gitlab，让jenkins能够直接读取修改gitlab中的代码，方便项目的构建 安装gitlab-plugin 在“系统管理” -&gt; “系统设置“ -&gt; “Gitlab” 中配置对应的gitlab信息 点击“Test Connection”测试下配置是否成功 Publish Over SSH 通过ssh连接远程服务器，并能执行脚本部署项目 安装publish-over-ssh 在“系统管理” -&gt; “系统设置“ -&gt; “Publish over SSH” 中配置对应的ssh信息 Key中填登录远程服务器的密码(ssh免密码登录) 点击”SSH Servers”后的“增加”按钮，新增一个远程服务器 点开“高级…”按钮，能进一步的配置端口等信息。 配置为Server信息后，点击”Test Configuration”按钮测试是否能够连接成功。 监测代码变动自动部署 点击左侧边栏的“新建”按钮，新建一个任务。 填写项目的名称，并选择一种构建的方式，此时我们选择第一个，构建一个自由风格的软件项目，然后点击“OK”按钮创建任务，并进行详细的配置 默认设置里填写项目名和描述，并选择之前配置好的要连接的gitlab 配置源码，填写要构建项目的源码仓库地址，并指定要构建的分支 配置触发器，选择触发构建的方式，可以通过hook，根据jenkins提供的地址，放到gitlab中的hook配置中，就会自动触发构建。此时我们选择的是定时检测项目变动，如果检测到分支有新的变动就触发构建，如果感觉一分钟时间太频繁的话，可以自己设置时间频率。 配置构建，构建选用的是“Invoke top-level Maven target”,填写对应的maven命令，就会自动执行maven命令进行侯建 配置构建后操作， 该行为会在构建完成后执行，我们选用的是“Send build artifacts over SSH”的方式，把构建完成的jar包发送到远程服务器上用ssh命令执行启动，此时jenkins所有机器的默认路径是任务所在的目录，远程机器的默认路径是之前publish-over-ssh中指定的文件地址。Source files指定要传送到远程服务器上的文件，remote directory指定的是传送到远程服务器上的文件地址，Remove prefix是值要去除的文件目录，不然传送到远程服务器也会带有该目录层级结构的。exec Command里输入的是在远程服务器上要执行的指令。 项目构建后会有构建历史，点击进去，选择“Console Output”就可以查看构建过程中的执行记录 项目回滚 上面虽然实现了项目的自动部署，但是有时部署失败的时候我们需要回滚到指定版本的构建，这样才能更灵活的进行项目的构建部署。我们可以选择“参数化的构建过程”进行传递不同的参数来选择是进行新的构建还是回滚 如果要在实现回滚，一定要在构建后将，构建完成的文件进行存档，方便以后回滚的时候使用 使用参数化构建过程，让后面的脚步可以根据不同的变量执行不同的操作。添加“Choice”参数配置不同的选项，让选择发布还是回滚，添加“String Parameter”参数来传递要回滚的版本号。 构建选择“Execute Shell”的方式，自己根据变量，自定义构建的脚本，此时如果是发布安装maven的构建过程进行新的构建，如果是回滚，知道历史构建后的文件，复制到当前构建结果目录。 点击构建，根据不同的参数选择发布还是回滚，回滚的时候填写要回滚到的历史版本号","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"尾调用优化","date":"2016-12-15T16:00:00.000Z","path":"2016/12/16/JavaScript/尾调用优化/","text":"什么是尾调用 尾调用（Tail Call）是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。 12345678910111213141516171819202122232425262728293031// 尾调用function f(x)&#123; return g(x);&#125;// 不属于尾调用， 调用函数g之后，还有赋值操作function f(x)&#123; let y = g(x); return y;&#125;// 不属于尾调用， 调用后还有操作，即使写在一行内function f(x)&#123; return g(x) + 1;&#125;// 不属于尾调用，下面的两个函数等同function f(x)&#123; g(x);&#125;function f(x)&#123; g(x); return undefined;&#125;// 尾调用, 虽然尾调用没出现在函数尾部，但是只要是最后一步操作即可function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 尾调用优化 函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 12345678// 不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 1234567891011// 正常递归，复杂度 O(n)function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;// 尾递归，复杂度 O(1)function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125; 来源： http://es6.ruanyifeng.com/#docs/function#尾调用优化","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"},{"name":"es6","slug":"es6","permalink":"http://haiyue.me/tags/es6/"}]},{"title":"深入理解 Java 虚拟机笔记","date":"2016-12-05T16:00:00.000Z","path":"2016/12/06/Java/jvm/","text":"Java 虚拟机屏蔽了与具体操作系统平台相关的信息,使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码),就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时,实际上最终还是把字节码解释成具体平台上的机器指令执行。 Java 的优点 是一门结构严谨、面向对象的编程语言。 摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想。 提供了一种相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界问题。 实现了热点代码检测和运行时编译及优化，使得 Java 应用能随着运行时间的增加而获得更高的性能。 有一套完善的应用程序接口和无数的来自商业机构和开源社区的第三方类库来帮助实现各种各样的功能。 Java 平台的逻辑结构 JVM JVM 是一种基于下层的操作系统和硬件平台并利用软件方法来实现的抽象的计算机，可以在上面执行 Java 的字节码程序。简单的说，JVM 就是 Java 的虚拟机,有了 JVM 才能运行 Java 程序。 Java 编译器只需面向 JVM，生成 JVM 能理解的代码或字节码文件。Java 源文件经编译器，编译成字节码程序，通过 JVM 将每一条指令翻译成不同平台机器码，通过特定平台运行。 class 文件的组成 结构信息。包括 class 文件格式版本号及各部分的数量与大小的信息。 元数据。对应于 Java 源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池。 方法信息。对应 Java 源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息。 类的层次关系和加载顺序 类执行机制 JVM 是基于栈的体系结构来执行 class 字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。 内存区域 Java 虚拟机在执行 Java 程序的过程中会把他所管理的内存划分为若干个不同的数据区域。 Java 虚拟机规范将 JVM 所管理的内存分为以下几个运行时数据区：程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区。 程序计数器 一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。 每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。 当线程在执行一个 Java 方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是 Native 方法（调用本地操作系统方法）时，该计数器的值为空。 该内存区域是唯一一个在 Java 虚拟机规范中么有规定任何 OOM（内存溢出：OutOfMemoryError）情况的区域。 Java 虚拟机栈 该区域也是线程私有的，它的生命周期也与线程相同。 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。 对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。 栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。 在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的 Code 属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。 Java 虚拟机栈的异常 在 Java 虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是 StackOverflowError 异常，而不会得到 OutOfMemoryError 异常。而在多线程环境下，则会抛出 OutOfMemoryError 异常。 局部变量表 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，即在 Java 程序被编译成 Class 文件时，就确定了所需分配的最大局部变量表的容量。当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 局部变量表的容量以变量槽（Slot）为最小单位。在虚拟机规范中并没有明确指明一个 Slot 应占用的内存空间大小（允许其随着处理器、操作系统或虚拟机的不同而发生变化），一个 Slot 可以存放一个32位以内的数据类型：boolean、byte、char、short、int、float、reference 和 returnAddresss。reference 是对象的引用类型，returnAddress 是为字节指令服务的，它执行了一条字节码指令的地址。对于 64 位的数据类型（long和double），虚拟机会以高位在前的方式为其分配两个连续的 Slot 空间。 虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从 0 开始到局部变量表最大的 Slot 数量，对于 32 位数据类型的变量，索引 n 代表第 n 个 Slot，对于 64 位的，索引 n 代表第 n 和第 n+1 两个 Slot。 在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），则局部变量表中的第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，占用从1开始的局部变量 Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的 Slot。 局部变量表中的 Slot 是可重用的，方法体中定义的变量，作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量对应的 Slot 就可以交给其他变量使用。这样的设计不仅仅是为了节省空间，在某些情况下 Slot 的复用会直接影响到系统的而垃圾收集行为。 操作数栈 操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32 位数据类型所占的栈容量为 1,64 位数据类型所占的栈容量为 2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。 Java 虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称 Java 虚拟机是基于栈的，这点不同于 Android 虚拟机，Android 虚拟机是基于寄存器的。 基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差。 动态连接 每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如 final、static 域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。 方法返回地址 当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的 PC 计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令。 本地方法栈 该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。 Java 堆 Java Heap 是 Java 虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap 是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。 根据 Java 虚拟机规范的规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出 OutOfMemoryError 异常。 方法区 方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 方法区域又被称为“永久代”，但这仅仅对于 Sun HotSpot 来讲，JRockit 和 IBM J9 虚拟机中并不存在永久代的概念。 Java 虚拟机规范把方法区描述为 Java 堆的一个逻辑部分，而且它和 Java Heap 一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域比较少出现。该区域的内存回收目标主要针是对废弃常量的和无用类的回收。 运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 运行时常量池相对于 Class 文件常量池的另一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入 Class 文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是 String 类的 intern（）方法。 直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受 Java 堆大小的限制，但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致 OutOfMemoryError 异常出现。 在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。 内存溢出 在多线程情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。操作系统为每个进程分配的内存是有限制的，虚拟机提供了参数来控制 Java 堆和方法区这两部分内存的最大值，忽略掉程序计数器消耗的内存（很小），以及进程本身消耗的内存，剩下的内存便给了虚拟机栈和本地方法栈，每个线程分配到的栈容量越大，可以建立的线程数量自然就越少。因此，如果是建立过多的线程导致的内存溢出，在不能减少线程数的情况下，就只能通过减少最大堆和每个线程的栈容量来换取更多的线程。 内存泄露是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java 中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们 new 了对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这边会造成内存泄露， 内存溢出是指程序所需要的内存超出了系统所能分配的内存（包括动态扩展）的上限。 对象实例化分析1Object obj = new Object(); 假设该语句出现在方法体中，obj 会作为引用类型（reference）的数据保存在 Java 栈的本地变量表中，而会在 Java 堆中保存该引用的实例化对象，Java 堆中还包含能查找到此对象类型数据的地址信息（如对象类型、父类、实现的接口、方法等），这些类型数据则保存在方法区中。 由于 reference 类型在 Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到 Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄池和直接使用指针。这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是 reference 中存放的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式的最大好处是速度快，它节省了一次指针定位的时间开销。目前 Java 默认使用的 HotSpot 虚拟机采用的便是是第二种方式进行对象访问的。 类文件结构 Class 文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部都是程序运行的必要数据。 根据 Java 虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：无符号数和表。无符号数属于基本数据类型，以 u1、u2、u4、u8 来分别代表 1、2、4、8 个字节的无符号数。表是由多个无符号数或其他表作为数据项构成的符合数据类型，所有的表都习惯性地以“_info”结尾。 magic 与 version 每个 Class 文件的头 4 个字节称为魔数（magic），它的唯一作用是判断该文件是否为一个能被虚拟机接受的 Class 文件。它的值固定为 0xCAFEBABE。紧接着 magic 的 4 个字节存储的是 Class 文件的次版本号和主版本号，高版本的 JDK 能向下兼容低版本的 Class 文件，但不能运行更高版本的 Class 文件。 类初始化 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的 Java 代码场景是：使用 new 关键字实例化对象时、读取或设置一个类的静态字段（static）时（被 static 修饰又被 final 修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。 使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。 通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类： 常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化 通过数组定义来引用类，不会触发类的初始化但是会触发了另一个名为“LLConst”的类的初始化，它是一个由虚拟机自动生成的、直接继承于java.lang.Object 的子类，创建动作由字节码指令 newarray 触发，很明显，这是一个对数组引用类型的初初始化，而该数组中的元素仅仅包含一个对 Const 类的引用，并没有对其进行初始化。如果我们加入对 con 数组中各个 Const 类元素的实例化代码，便会触发 Const 类的初始化 接口也有初始化过程，在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成类构造器，用于初始化接口中定义的成员变量（实际上是 static final 修饰的全局常量）。二者在初始化时最主要的区别是：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。这点也与类初始化的情况很不同，调用类中的 static final 常量时并不会 触发该类的初始化，但是调用接口中的 static final 常量时便会触发该接口的初始化。 类加载机制 ？？？多态性实现机制——静态分派与动态分派 ？？？Java 语法糖 语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。 Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。 泛型是 JDK1.5 之后引入的一项新特性，Java 语言在还没有出现泛型时，只能通过 Object 是所有类型的父类和类型强制转换这两个特点的配合来实现泛型的功能，这样实现的泛型功能要在程序运行期才能知道 Object 真正的对象类型，在 javac 编译期，编译器无法检查这个 Object 的强制转型是否成功，这便将一些风险转接到了程序运行期中。Java 语言在 JDK1.5 之后引入的泛型实际上只在程序源码中存在，在编译后的字节码文件中，就已经被替换为了原来的原生类型，并且在相应的地方插入了强制转型代码，所以泛型技术实际上是 Java 语言的一颗语法糖，Java 语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为伪泛型。 javac 编译 javac 编译器称为前端编译器，将.java文件编译成为.class文件。相对应的还有后端编译器，它在程序运行期间将字节码转变成机器码（现在的 Java 程序在运行时基本都是解释执行加编译执行），如 HotSpot 虚拟机自带的 JIT（Just In Time Compiler）编译器（分 Client 端和 Server 端）。 词法、语法分析 词法分析是将源代码的字符流转变为标记（Token）集合。单个字符是程序编写过程中的的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符等都可以成为标记，比如整型标志 int 由三个字符构成，但是它只是一个标记，不可拆分。 语法分析是根据Token序列来构造抽象语法树的过程。抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，如 bao、类型、修饰符、运算符等。经过这个步骤后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。 填充符号表 完成了语法分析和词法分析之后，下一步就是填充符号表的过程。符号表是由一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到，在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码，在目标代码生成阶段，党对符号名进行地址分配时，符号表是地址分配的依据。 语义分析 语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是读结构上正确的源程序进行上下文有关性质的审查。语义分析过程分为标注检查和数据及控制流分析两个步骤： 标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量和赋值之间的数据类型是否匹配等。 数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。 字节码生成 字节码生成是 javac 编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。 实例构造器()方法和类构造器()方法就是在这个阶段添加到语法树之中的（这里的实例构造器并不是指默认的构造函数，而是指我们自己重载的构造函数，如果用户代码中没有提供任何构造函数，那编译器会自动添加一个没有参数、访问权限与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成了）。 JIT 编译 Java 程序最初是仅仅通过解释器解释执行的，即对字节码逐条解释执行，这种方式的执行速度相对会比较慢，尤其当某个方法或代码块运行的特别频繁时，这种方式的执行效率就显得很低。于是后来在虚拟机中引入了 JIT 编译器（即时编译器），当虚拟机发现某个方法或代码块运行特别频繁时，就会把这些代码认定为“Hot Spot Code”（热点代码），为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，完成这项任务的正是 JIT 编译器。 HotSpot 虚拟机中内置了两个JIT编译器：Client Complier 和 Server Complier，分别用在客户端和服务端，目前主流的 HotSpot 虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。 运行过程中会被即时编译器编译的“热点代码”有两类： 被多次调用的方法。 被多次调用的循环体。 目前主要的热点判定方式 基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。 基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。 在 HotSpot 虚拟机的热点判定方式 在 HotSpot 虚拟机中使用的是基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。 方法调用计数器用来统计方法调用的次数，在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法被调用的次数。 回边计数器用于统计一个方法中循环体代码执行的次数（准确地说，应该是回边的次数，因为并非所有的循环都是回边），在字节码中遇到控制流向后跳转的指令就称为“回边”。 在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阀值，当计数器的值超过了阀值，就会触发JIT编译。触发了 JIT 编译后，在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成为止（编译工作在后台线程中进行）。当编译工作完成后，下一次调用该方法或代码时，就会使用已编译的版本。 对象引用Java 中的垃圾回收一般是在 Java 堆中进行，因为堆中几乎存放了 Java 中所有的对象实例。在 JDK1.2 之前，Java 中的引用定义很很纯粹：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块数据代表着一个引用。但在 JDK1.2 之后，Java 对引用的概念进行了扩充，将其分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，引用强度依次减弱。 强引用：如“Object obj = new Object（）”，这类引用是 Java 程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2 之后提供了 SoftReference 类来实现软引用。 弱引用：它也是用来描述非需对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存岛下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK1.2 之后，提供了 WeakReference 类来实现弱引用。 虚引用：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2 之后提供了 PhantomReference 类来实现虚引用。 垃圾对象的判定引用计数算法 给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1，当引用失效时，计数器值就减1，任何时刻计数器都为 0 的对象就是不可能再被使用的。 引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的选择，当 Java 语言并没有选择这种算法来进行垃圾回收，主要原因是它很难解决对象之间的相互循环引用问题。 根搜索算法 这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，就证明此对象是不可用的。Java 和 C# 中都是采用根搜索算法来判定对象是否存活的。 在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行根搜索后发现没有与 GC Roots 相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法，或 finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。如果该对象被判定为有必要执行 finalize()方法，那么这个对象将会被放置在一个名为 F-Queue 队列中，并在稍后由一条由虚拟机自动建立的、低优先级的 Finalizer 线程去执行 finalize()方法。finalize()方法是对象逃脱死亡命运的最后一次机会（因为一个对象的 finalize()方法最多只会被系统自动调用一次），稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果要在 finalize()方法中成功拯救自己，只要在 finalize()方法中让该对象重引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。 垃圾收集算法标记—清除算法 标记—清除算法是最基础的收集算法，它分为“标记”和“清除”两个阶段：首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的根搜索算法中判定垃圾对象的标记过程。（会造成大量的内存碎片） 标记—整理算法 复制算法比较适合于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如标记—整理算法。该算法标记的过程与标记—清除算法中的标记过程一样，但对标记后出的垃圾对象的处理情况有所不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。（不会产生内存碎片，成本相对较高） 分代收集 当前商业虚拟机的垃圾收集 都采用分代收集，它根据对象的存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代。在新生代中，每次垃圾收集时都会发现有大量对象死去，只有少量存活，因此可选用复制算法来完成收集，而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清除算法或标记—整理算法来进行回收。 垃圾收集器内存的分配策 对象优先在 Eden 分配。 大对象直接进入老年代。 长期存活的对象将进入老年代。 垃圾回收策略 新生代 GC（Minor GC）：发生在新生代的垃圾收集动作，因为 Java 对象大多都具有朝生夕灭的特性，因此Minor GC 非常频繁，一般回收速度也比较快。 老年代 GC（Major GC/Full GC）：发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次 Minor GC。由于老年代中的对象生命周期比较长，因此 Major GC 并不频繁，一般都是等待老年代满了后才进行 Full GC，而且其速度一般会比 Minor GC 慢 10 倍以上。另外，如果分配了 Direct Memory，在老年代中进行 Full GC时，会顺便清理掉 Direct Memory 中的废弃对象。 性能调优 我们可以通过给 Java 虚拟机分配超大堆（前提是物理机的内存足够大）来提升服务器的响应速度，但分配超大堆的前提是有把握把应用程序的 Full GC 频率控制得足够低，因为一次 Full GC 的时间造成比较长时间的停顿。控制 Full GC 频率的关键是保证应用中绝大多数对象的生存周期不应太长，尤其不能产生批量的、生命周期长的大对象，这样才能保证老年代的稳定。 Direct Memory 在堆内存外分配，而且二者均受限于物理机内存，且成负相关关系，因此分配超大堆时，如果用到了 NIO 机制分配使用了很多的 Direct Memory，则有可能导致 Direct Memory 的 OutOfMemoryError 异常，这时可以通过 -XX:MaxDirectMemorySize 参数调整 Direct Memory 的大小。","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"},{"name":"jvm","slug":"jvm","permalink":"http://haiyue.me/tags/jvm/"}]},{"title":"RPC框架motan使用","date":"2016-11-09T16:00:00.000Z","path":"2016/11/10/RPC/motan-hello/","text":"简介 motan是新浪微博开源的一套轻量级、方便使用的RPC框架 项目地址：https://github.com/weibocom/motan Hello World 使用的过程分为Server端和Client端，Server提供RCP的服务接口，Client端发起调用获取结果。 maven的pom文件配置 123456789101112131415161718192021&lt;properties&gt; &lt;motan.version&gt;0.2.1&lt;/motan.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.weibo&lt;/groupId&gt; &lt;artifactId&gt;motan-core&lt;/artifactId&gt; &lt;version&gt;$&#123;motan.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.weibo&lt;/groupId&gt; &lt;artifactId&gt;motan-transport-netty&lt;/artifactId&gt; &lt;version&gt;$&#123;motan.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.weibo&lt;/groupId&gt; &lt;artifactId&gt;motan-springsupport&lt;/artifactId&gt; &lt;version&gt;$&#123;motan.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Server 端 暴露的接口 12345678package com.raventech.user.motan;/** * @author liuhaiming on 10/11/2016. */public interface HelloService &#123; String hello(String world);&#125; 暴露接口的实现类 1234567891011package com.raventech.user.motan;/** * @author liuhaiming on 10/11/2016. */public class HelloServiceImpl implements HelloService &#123; @Override public String hello(String world) &#123; return \"hello \" + world; &#125;&#125; xml配置文件，暴露接口 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:motan=\"http://api.weibo.com/schema/motan\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://api.weibo.com/schema/motan http://api.weibo.com/schema/motan.xsd\"&gt; &lt;bean id=\"helloServiceImpl\" class=\"com.raventech.user.motan.HelloServiceImpl\"/&gt; &lt;motan:service interface=\"com.raventech.user.motan.HelloService\" ref=\"helloServiceImpl\" export=\"8002\"/&gt;&lt;/beans&gt; 启动服务的方法（运行main方法就可以启动服务了） 12345678910111213package com.raventech.user;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author liuhaiming on 10/11/2016. */public class Server &#123; public static void main(String[] args) &#123; new ClassPathXmlApplicationContext(\"classpath:motan-server.xml\"); System.out.println(\"Server start ...\"); &#125;&#125; Client 端 要请求的接口（不论包名还是类名都要和Server端的一样） 12345678package com.raventech.user.motan;/** * @author liuhaiming on 10/11/2016. */public interface HelloService &#123; String hello(String world);&#125; xml配置文件，获取接口信息 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:motan=\"http://api.weibo.com/schema/motan\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://api.weibo.com/schema/motan http://api.weibo.com/schema/motan.xsd\"&gt; &lt;motan:referer id=\"helloService\" interface=\"com.raventech.user.motan.HelloService\" directUrl=\"127.0.0.1:8002\"/&gt;&lt;/beans&gt; 调用服务的方法（运行main方法就可以调用服务了） 12345678910111213141516package com.raventech.web;import com.raventech.user.motan.HelloService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author liuhaiming on 10/11/2016. */public class Client &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:motan-client.xml\"); HelloService fooService = (HelloService) applicationContext.getBean(\"helloService\"); System.out.println(fooService.hello(\"world\")); &#125;&#125; 调用响应结果 使用Consul作为注册中心 在集群环境下使用motan需要依赖Consul等服务发现组件 Consul的介绍安装和使用 maven的pom文件配置(在上面的基础上增加consul)12345&lt;dependency&gt; &lt;groupId&gt;com.weibo&lt;/groupId&gt; &lt;artifactId&gt;motan-registry-consul&lt;/artifactId&gt; &lt;version&gt;$&#123;motan.version&#125;&lt;/version&gt;&lt;/dependency&gt; Server 端 xml配置文件添加consul的注册 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:motan=\"http://api.weibo.com/schema/motan\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://api.weibo.com/schema/motan http://api.weibo.com/schema/motan.xsd\"&gt; &lt;motan:registry regProtocol=\"consul\" name=\"registry\" address=\"127.0.0.1:8500\"/&gt; &lt;bean id=\"helloServiceImpl\" class=\"com.raventech.user.motan.HelloServiceImpl\"/&gt; &lt;motan:service interface=\"com.raventech.user.motan.HelloService\" ref=\"helloServiceImpl\" registry=\"registry\" export=\"8002\"/&gt;&lt;/beans&gt; 启动服务的方法要在程序启动后调用心跳开关，将服务注册到consul，不然Client无法调用 （别的和上文Hello World一样不变，运行main方法启动服务） 12345678910111213141516package com.raventech.user;import com.weibo.api.motan.common.MotanConstants;import com.weibo.api.motan.util.MotanSwitcherUtil;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author liuhaiming on 10/11/2016. */public class Server &#123; public static void main(String[] args) &#123; new ClassPathXmlApplicationContext(\"classpath:motan-server.xml\"); MotanSwitcherUtil.setSwitcherValue(MotanConstants.REGISTRY_HEARTBEAT_SWITCHER, true); System.out.println(\"Server start ...\"); &#125;&#125; Client 端 xml配置文件添加consul的服务发现 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:motan=\"http://api.weibo.com/schema/motan\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://api.weibo.com/schema/motan http://api.weibo.com/schema/motan.xsd\"&gt; &lt;motan:registry regProtocol=\"consul\" name=\"registry\" address=\"127.0.0.1:8500\"/&gt; &lt;motan:referer id=\"helloService\" interface=\"com.raventech.user.motan.HelloService\" registry=\"registry\"/&gt;&lt;/beans&gt; 别的和上文Hello World一样不变，运行Client类的main方法调用服务 使用注解的方式集成到Spring Boot项目中 项目改成Spring Boot后抛弃了繁琐的xml文件配置改为用注解的方式。motan也支持注解的方式进行配置，这样更加方便了代码的集成和风格的统一。 继续在前面的代码中进行修改，没提到的保持不变 Server 端 删除motan-server.xml配置文件 用注解加载motan需要的配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.raventech.user.config;import com.weibo.api.motan.config.springsupport.AnnotationBean;import com.weibo.api.motan.config.springsupport.BasicServiceConfigBean;import com.weibo.api.motan.config.springsupport.ProtocolConfigBean;import com.weibo.api.motan.config.springsupport.RegistryConfigBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author liuhaiming on 10/11/2016. */@Configurationpublic class MotanConfiguration &#123; @Bean public AnnotationBean motanAnnotationBean() &#123; AnnotationBean motanAnnotationBean = new AnnotationBean(); motanAnnotationBean.setPackage(\"com.raventech.user.motan\"); return motanAnnotationBean; &#125; @Bean(name = \"motan\") public ProtocolConfigBean protocolConfig1() &#123; ProtocolConfigBean config = new ProtocolConfigBean(); config.setDefault(true); config.setName(\"motan\"); config.setMaxContentLength(1048576); return config; &#125; @Bean(name = \"registry\") public RegistryConfigBean registryConfig() &#123; RegistryConfigBean config = new RegistryConfigBean(); config.setRegProtocol(\"consul\"); config.setAddress(\"127.0.0.1:8500\"); return config; &#125; @Bean public BasicServiceConfigBean baseServiceConfig() &#123; BasicServiceConfigBean config = new BasicServiceConfigBean(); config.setExport(\"motan:8002\"); config.setRegistry(\"registry\"); return config; &#125;&#125; 暴露接口的实现类加上@MotanService注解，自动生成bean 1234567891011121314package com.raventech.user.motan;import com.weibo.api.motan.config.springsupport.annotation.MotanService;/** * @author liuhaiming on 10/11/2016. */@MotanServicepublic class HelloServiceImpl implements HelloService &#123; @Override public String hello(String world) &#123; return \"hello \" + world; &#125;&#125; 启动服务的方法就是启动Spring Boot项目，并在在程序启动后调用心跳开关 (运行main方法启动服务) 123456789101112131415161718package com.raventech.user;import com.weibo.api.motan.common.MotanConstants;import com.weibo.api.motan.util.MotanSwitcherUtil;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author liuhaiming on 10/11/2016. */@SpringBootApplicationpublic class Server &#123; public static void main(String[] args) &#123; SpringApplication.run(Server.class, args); MotanSwitcherUtil.setSwitcherValue(MotanConstants.REGISTRY_HEARTBEAT_SWITCHER, true); System.out.println(\"Server start ...\"); &#125;&#125; Client 端 删除motan-client.xml配置文件和Client.java启动文件，已经没用了 用注解加载motan需要的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.raventech.web.config;import com.weibo.api.motan.config.springsupport.AnnotationBean;import com.weibo.api.motan.config.springsupport.BasicRefererConfigBean;import com.weibo.api.motan.config.springsupport.ProtocolConfigBean;import com.weibo.api.motan.config.springsupport.RegistryConfigBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author liuhaiming on 10/11/2016. */@Configurationpublic class MotanConfiguration &#123; @Bean public AnnotationBean motanAnnotationBean() &#123; AnnotationBean motanAnnotationBean = new AnnotationBean(); # 添加用到motan注解的类的包名 motanAnnotationBean.setPackage(\"com.raventech.web.controller\"); return motanAnnotationBean; &#125; @Bean(name = \"motan\") public ProtocolConfigBean protocolConfig1() &#123; ProtocolConfigBean config = new ProtocolConfigBean(); config.setDefault(true); config.setName(\"motan\"); config.setMaxContentLength(1048576); return config; &#125; @Bean(name = \"registry\") public RegistryConfigBean registryConfig() &#123; RegistryConfigBean config = new RegistryConfigBean(); config.setRegProtocol(\"consul\"); config.setAddress(\"127.0.0.1:8500\"); return config; &#125; @Bean(name = \"basicRefererConfig\") public BasicRefererConfigBean basicRefererConfigBean() &#123; BasicRefererConfigBean config = new BasicRefererConfigBean(); config.setProtocol(\"motan\"); config.setRegistry(\"registry\"); config.setThrowException(true); return config; &#125;&#125; 调用方法（在Controller中使用） 123456789101112131415161718192021222324package com.raventech.web.controller;import com.raventech.user.motan.HelloService;import com.raventech.web.common.BaseController;import com.weibo.api.motan.config.springsupport.annotation.MotanReferer;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;/** * @author liuhaiming on 10/11/2016. */@RestController@RequestMapping(\"/motan\")public class HelloController extends BaseController &#123; @MotanReferer(basicReferer = \"basicRefererConfig\") private HelloService helloService; @RequestMapping(value = \"/hello\", method = RequestMethod.GET) public String hello() throws Exception &#123; return helloService.hello(\"world\"); &#125;&#125; 启动Spring Boot项目，在浏览器中访问http://127.0.0.1:8080/motan/hello就可以获取验证结果","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"},{"name":"motan","slug":"motan","permalink":"http://haiyue.me/tags/motan/"}]},{"title":"使用ELK管理日志","date":"2016-11-03T16:00:00.000Z","path":"2016/11/04/Architecture/elk/","text":"Logstash简介 官网： https://www.elastic.co/products/logstash 检查java环境 需要java8以上的环境支撑 1234$ java -versionjava version \"1.8.0_111\"Java(TM) SE Runtime Environment (build 1.8.0_111-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode) 下载安装1234567891011$ wget https://artifacts.elastic.co/downloads/logstash/logstash-5.0.0.tar.gz$ tar zxvf logstash-5.0.0.tar.gz$ cd logstash-5.0.0/$ ./bin/logstash -e 'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;'Sending Logstash logs to /home/nlp/logstash-5.0.0/logs which is now configured via log4j2.properties.The stdin plugin is now waiting for input:[2016-11-03T16:05:11,070][INFO ][logstash.pipeline ] Starting pipeline &#123;\"id\"=&gt;\"main\", \"pipeline.workers\"=&gt;4, \"pipeline.batch.size\"=&gt;125, \"pipeline.batch.delay\"=&gt;5, \"pipeline.max_inflight\"=&gt;500&#125;[2016-11-03T16:05:11,091][INFO ][logstash.pipeline ] Pipeline main started[2016-11-03T16:05:11,133][INFO ][logstash.agent ] Successfully started Logstash API endpoint &#123;:port=&gt;9600&#125;hello world2016-11-03T08:05:47.176Z iZ25ueoepxdZ hello world 自定义配置文件 将日志文件输出到elasticsearch 12345678910111213$ vim test.confinput &#123; file &#123; path =&gt; [\"/alidata/logs/web/web-info.log\"] start_position =&gt; \"beginning\" &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [\"127.0.0.1:9200\"] &#125;&#125; Elasticsearch简介 官网：https://www.elastic.co/products/elasticsearch 下载安装123456789101112131415161718$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.0.0.tar.gz$ tar zxvf elasticsearch-5.0.0.tar.gz$ cd elasticsearch-5.0.0/$ ./bin/elasticsearch$ curl http://localhost:9200&#123; \"name\" : \"R9IzZP9\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"TGY12_FFSQCfp42g5NZ1VQ\", \"version\" : &#123; \"number\" : \"5.0.0\", \"build_hash\" : \"253032b\", \"build_date\" : \"2016-10-26T04:37:51.531Z\", \"build_snapshot\" : false, \"lucene_version\" : \"6.2.0\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; 后台运行1$ ./bin/elasticsearch -d -p es.pid // 进程id写到es.pid文件中 Kibana简介 官网：https://www.elastic.co/products/kibana 下载安装123456$ wget https://artifacts.elastic.co/downloads/kibana/kibana-5.0.0-linux-x86_64.tar.gz$ tar xvf kibana-5.0.0-linux-x86_64.tar$ cd kibana-5.0.0-linux-x86_64/$ vim config/kibana.ymlserver.host: \"*.205.*.30\" // 外网ip地址，不然只能本机才能访问elasticsearch.url: \"http://localhost:9200\" // 集成elasticsearch 用浏览器打开查看： http://*.205.*.30:5601 后台运行1$ nohup ./bin/kibana &gt; nohup.log 2&gt;&amp;1 &amp;","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"Spring Boot 中使用 Jedis 来操作 Redis","date":"2016-10-26T16:00:00.000Z","path":"2016/10/27/SpringBoot/spring-boot-jedis/","text":"把之前老的项目切换到用 Spring Boot 时，由于抛弃了 xml 配置文件的使用，需要把之前 Jedis 配置现在用注解的形式重新实现一遍。 老的代码 config.properties 12345678910# redis数据库连接配置(covert)redis.url=redis://:name@host:6379/2# 最大实例数redis.maxTotal=100# 最大空闲实例数redis.maxIdle=10# (创建实例时)最大等待时间redis.maxWaitMillis=10000# (创建实例时)是否验证redis.testOnBorrow=true spring.xml 123456789101112131415161718192021&lt;!--加载外部数据库配置--&gt;&lt;context:property-placeholder location=\"classpath:config.properties\" file-encoding=\"utf-8\" ignore-unresolvable=\"true\"/&gt;&lt;!-- 配置redis池，依次为最大实例数，最大空闲实例数，(创建实例时)最大等待时间，(创建实例时)是否验证 --&gt;&lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxTotal\" value=\"$&#123;redis.maxTotal&#125;\"/&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.maxIdle&#125;\"/&gt; &lt;property name=\"maxWaitMillis\" value=\"$&#123;redis.maxWaitMillis&#125;\"/&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.testOnBorrow&#125;\"/&gt;&lt;/bean&gt;&lt;bean id=\"convertShardInfo\" class=\"redis.clients.jedis.JedisShardInfo\"&gt; &lt;constructor-arg name=\"host\" value=\"$&#123;redis.url&#125;\"/&gt;&lt;/bean&gt;&lt;bean id=\"convertJedisPool\" class=\"redis.clients.jedis.ShardedJedisPool\"&gt; &lt;constructor-arg index=\"0\" ref=\"jedisPoolConfig\"/&gt; &lt;constructor-arg index=\"1\"&gt; &lt;list&gt; &lt;ref bean=\"convertShardInfo\"/&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 新的代码 application.yml 1234567891011# redis数据库连接配置(covert)redisConfig: url: \"redis://:name@host:6379/2\" # 最大实例数 maxTotal: 100 # 最大空闲实例数 maxIdle: 10 # (创建实例时)最大等待时间 maxWaitMillis: 10000 # (创建实例时)是否验证 testOnBorrow: true RedisConfig.java 123456789101112package com.raventech.web.models.yml;@Component@ConfigurationProperties(prefix = \"redisConfig\")public class RedisConfig implements Serializable &#123; private static final long serialVersionUID = 1097752157567754456L; private String url; private Integer maxTotal; private Integer maxIdle; private Long maxWaitMillis; private Boolean testOnBorrow; ...... JedisConfiguration.java 123456789101112131415161718@Configuration@ComponentScan(&#123;\"com.raventech.web.models.yml\"&#125;) // 解决 Configuration 注解中使用 Autowired 注解 IDE 报错public class JedisConfiguration &#123; @Autowired RedisConfig redisConfig; @Bean public ShardedJedisPool convertJedisPool() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(redisConfig.getMaxTotal()); jedisPoolConfig.setMaxIdle(redisConfig.getMaxIdle()); jedisPoolConfig.setMaxWaitMillis(redisConfig.getMaxWaitMillis()); jedisPoolConfig.setTestOnBorrow(redisConfig.getTestOnBorrow()); List&lt;JedisShardInfo&gt; jedisShardInfoList = new ArrayList&lt;&gt;(); jedisShardInfoList.add(new JedisShardInfo(redisConfig.getUrl())); return new ShardedJedisPool(jedisPoolConfig, jedisShardInfoList); &#125;&#125; 应用12345678910@Autowiredprivate ShardedJedisPool convertJedisPool;public String convertRedisGet(String key) &#123; ShardedJedis resource = convertJedisPool.getResource(); String result = resource.get(key); resource.close(); return result;&#125;&#125;","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"Configuration 注解中使用 Autowired 注解 IDE 报错","date":"2016-10-25T16:00:00.000Z","path":"2016/10/26/SpringBoot/spring-boot-no-beans/","text":"在 Spring Boot 项目中会用 @Configuration 注解来初始化配置, 这时可以通过 @autowired 自动注入封装好的model对象, 方便使用yml中的配置的数据。这样做代码运行没问题，通过该对象也可以成功的获取yml配置文件中的数据，但是 IDE 却给出 “Could not autowird. No beans of’RedisConfig’ type found.” 的错误提示。 我们手动的在 @Configuration 注解下面添加 @ComponentScan 注解并指定所需model类的包地址就可以解决整个问题了。原因估计是因为在项目的启动的最初阶段，IDE 还没有扫描到model类，无法发现对应的 bean，于是就需要我们手动的给其指定需要扫描的包了。","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"yml 文件中使用环境变量","date":"2016-10-24T16:00:00.000Z","path":"2016/10/25/SpringBoot/yml-evn/","text":"Spring Boot 中可以用 spring.profiles.active 参数来指定系统环境，让系统加载不同的配置文件。可以在程序启动的时候加上参数来指定需要的配置 1java -Dspring.profiles.active=&quot;dev&quot; -jar user.jar 当然我们也可以事先设置好系统的环境变量 1expoer SERVER_EVN=test 然后在 yml 文件中用 active: ${SERVER_EVN} 来动态的获取系统已设置好的数据。这样这台 test 服务器中的再启动 Spring Boot 项目的时候就可以不用每次都去设置参数了。 同时 yml 也支持 ${SERVER_EVN:dev} 这样的方式来设置默认值，此时如果环境变量中没有 SERVER_EVN ， active就会默认设置为”dev”。","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"Spring Boot 项目中只能有一个main方法","date":"2016-10-23T16:00:00.000Z","path":"2016/10/24/SpringBoot/spring-boot-single-main/","text":"对Spring Boot 项目用maven进行打包的时候报错以下错误 [ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.4.1.RELEASE:repackage (default) on project nlp-user: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:1.4.1.RELEASE:repackage failed: Unable to find a single main class from the following candidates [com.raventech.user.Application, com.raventech.user.util.Utils] -&gt; [Help 1] 原来是因为 Spring Boot 项目中只能有一个main方法，不然 spring-boot-maven-plugin 在打包的过程中会扫描到了多个 main 方法，然后就懵逼不知道用哪个作为启动方法了。 以前总喜欢在 Utils 中写个main方法来调试静态方法，看来以后用完就得随手把它给删除了。","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"Docker Hello World","date":"2016-10-08T16:00:00.000Z","path":"2016/10/09/Docker/docker-hello-world/","text":"查看linux版本123456$ lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.2.1511 (Core)Release: 7.2.1511Codename: Core Docker 环境准备 CentOS7 系统 CentOS-Extras 库中已带 Docker，可以直接安装 安装12$ su root# yum install docker 启动12# service docker startRedirecting to /bin/systemctl start docker.service 让它随系统启动自动加载12345# service docker startRedirecting to /bin/systemctl start docker.service# chkconfig docker on注意：正在将请求转发到“systemctl enable docker.service”。Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service. 镜像获取镜像12345678910# docker pull ubuntu:12.04Trying to pull repository docker.io/library/ubuntu ...12.04: Pulling from docker.io/library/ubuntu36cef014d5d4: Pull complete0d99ad4de1d2: Pull complete3e32dbf1ab94: Pull complete44710c456ffc: Pull complete56e70ac3b314: Pull completeDigest: sha256:0c25aa67baaff2b895882ce1e7d25efeeb15d0f38df6c099e23f481641cd6cabStatus: Downloaded newer image for docker.io/ubuntu:12.04 列出本地已有的镜像123# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/ubuntu 12.04 e216a057b1cb 12 days ago 103.6 MB REPOSITORY: 来自于哪个仓库 TAG: 镜像的标记（如果不指定具体的标记，则默认使用 latest 标记信息。） IMAGE ID: 它的 ID 号（唯一） CREATED: 创建时间 SIZE: 镜像大小 创建镜像 修改已有镜像 12345678910111213# docker run -t -i docker.io/ubuntu:12.04 /bin/bashroot@d7ac9b2f8cd7:/# apt-get updateroot@d7ac9b2f8cd7:/# apt-get install nodejsroot@d7ac9b2f8cd7:/# node -vv0.6.12root@d7ac9b2f8cd7:/# exitexit# docker commit -m \"add node evn\" -a \"haiyue\" d7ac9b2f8cd7 haiyue/nodejs:v1sha256:23c1c51f86414ae2ab3bf31f192537e6635c248044b61802c9e553ef4e46fbf9# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhaiyue/nodejs v1 23c1c51f8641 10 seconds ago 162.4 MBdocker.io/ubuntu 12.04 e216a057b1cb 12 days ago 103.6 MB -m 来指定提交的说明信息；-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID 信息。 利用 Dockerfile 来创建镜像12345678910111213# mkdir haiyue# cd haiyue/# This is a comment# vim DockerfileFROM docker.io/ubuntu:12.04MAINTAINER haiyueRUN apt-get updateRUN apt-get install nodejs# docker build -t=\"haiyue/nodejs:v2\" .# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhaiyue/nodejs v2 5190c35fc391 4 seconds ago 103.6 MBhaiyue/nodejs v1 23c1c51f8641 2 hours ago 162.4 MB 123456789Dockerfile 基本的语法是#: 注释FROM: 告诉 Docker 使用哪个镜像作为基础MAINTAINER: 维护者的信息RUN: 指令会在创建中运行build 指令后 -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径。*注意一个镜像不能超过 127 层 上传镜像(推送自己的镜像到仓库, Docker Hub)1234# docker push haiyue/nodejsThe push refers to a repository [haiyue/nodejs] (len: 1)Sending image listPushing repository haiyue/nodejs (2 tags) 存出和载入镜像 存出镜像 1# docker save -o nodejs_v1.tar haiyue/nodejs:v1 载入镜像 1# docker load &lt; nodejs_v1.tar 移除123456789# docker rmi haiyue/nodejs:v2Untagged: haiyue/nodejs:v2Deleted: sha256:5190c35fc391b6e9b3ed228a60a8342887fb555efcbb8a7bc351badfbb306550Deleted: sha256:01e2cd409ed3b15a1c34a2cd656772f51e472ec988b2011ec7d60de3a23e3111Deleted: sha256:daf78048142d52646c96e8ac025ea5d034270e15cab677838638767b00cb908e# docker rmi 23c1c51f8641Failed to remove image (23c1c51f8641): Error response from daemon: conflict: unable to delete 23c1c51f8641 (must be forced) - image is being used by stopped container 1586df1c5dc1# docker rmi -f 23c1c51f8641Untagged: haiyue/nodejs:v1 容器启动 新建并启动1234567# docker run haiyue/nodejs:v1 /bin/echo 'Hello world'Hello world# docker run -t -i haiyue/nodejs:v1 /bin/bashroot@66230fd659ff:/# node -vv0.6.12root@66230fd659ff:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin selinux srv sys tmp usr var 1234567891011-t 让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上 -i 则让容器的标准输入保持打开。docker run 来创建容器时，Docker 在后台运行的标准操作包括：检查本地是否存在指定的镜像，不存在就从公有仓库下载利用镜像创建并启动一个容器分配一个文件系统，并在只读的镜像层外面挂载一层可读写层从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去从地址池配置一个 ip 地址给容器执行用户指定的应用程序执行完毕后容器被终止 启动已终止容器12利用 docker start 命令，直接将一个已经终止的容器启动运行。docker restart 命令会将一个运行态的容器终止，然后再重新启动它。 守护态运行123456789# docker run -d haiyue/nodejs:v1 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"90a4f5809293e21f8eacf1945668b9076e68ed500ac3d3018fc902d947f57248# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES90a4f5809293 haiyue/nodejs:v1 \"/bin/sh -c 'while tr\" 9 seconds ago Up 8 seconds determined_sammet# docker logs 90a4f5809293hello worldhello worldhello world 终止容器12345678# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES90a4f5809293 haiyue/nodejs:v1 \"/bin/sh -c 'while tr\" 2 minutes ago Up 2 minutes determined_sammet# docker stop 90a4f580929390a4f5809293# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES90a4f5809293 haiyue/nodejs:v1 \"/bin/sh -c 'while tr\" 3 minutes ago Exited (137) 37 seconds ago determined_sammet 进入容器1234# docker attach 90a4f5809293hello worldhello worldhello world 导出和导入容器 导出容器 123# docker export 90a4f5809293 &gt; determined_sammet.tar# lsdetermined_sammet.tar 导入容器快照(容器快照文件中再导入为镜像) 1234567891011# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhaiyue/nodejs v1 23c1c51f8641 3 hours ago 162.4 MBdocker.io/ubuntu 12.04 e216a057b1cb 12 days ago 103.6 MB# cat determined_sammet.tar | docker import - haiyue/nodejs:v2sha256:7b78999d774ccb41d474fb2c851323191967593053a26982c11157c7621e9202# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhaiyue/nodejs v2 7b78999d774c 3 seconds ago 142.1 MBhaiyue/nodejs v1 23c1c51f8641 3 hours ago 162.4 MBdocker.io/ubuntu 12.04 e216a057b1cb 12 days ago 103.6 MB 1用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。 删除 12可以使用 docker rm 来删除一个处于终止状态的容器。如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"Nginx 安装","date":"2016-09-05T16:00:00.000Z","path":"2016/09/06/Nginx/nginx-install/","text":"安装编译工具及库文件 切换到root用户下面 yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel 安装 PCRE PCRE 作用是让 Ngnix 支持 Rewrite 功能。 wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz tar zxvf pcre-8.35.tar.gz cd pcre-8.35 ./configure make &amp;&amp; make install pcre-config –version 安装 Nginx wget http://nginx.org/download/nginx-1.6.2.tar.gz tar zxvf nginx-1.6.2.tar.gz cd nginx-1.6.2 ./configure –with-http_stub_status_module –with-http_ssl_module –with-pcre make &amp;&amp; make install /usr/local/nginx/sbin/nginx -v Nginx 配置 配置nginx.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061将/usr/local/nginx/conf/nginx.conf替换为以下内容user liuhaiming liuhaiming;worker_processes 4; # 设置值和CPU核心数一致error_log /usr/local/nginx/logs/nginx_error.log notice; #日志位置和日志级别pid /usr/local/nginx/logs/nginx.pid;#Specifies the value for maximum file descriptors that can be opened by this process.worker_rlimit_nofile 65535;events &#123; use epoll; worker_connections 65535;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 8m; sendfile on; tcp_nopush on; keepalive_timeout 60; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 2; gzip_types text/plain application/x-javascript text/css application/xml; gzip_vary on; #下面是server虚拟主机的配置 server &#123; listen 80; # 监听端口 server_name localhost; # 域名 charset utf-8; access_log logs/host.access.log main; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 检查配置文件ngnix.conf的正确性: /usr/local/nginx/sbin/nginx -t 启动 Nginx: /usr/local/nginx/sbin/nginx 访问站点: http://182.92.109.136/ Nginx 其他命令 /usr/local/nginx/sbin/nginx -s reload # 重新载入配置文件 /usr/local/nginx/sbin/nginx -s reopen # 重启 Nginx /usr/local/nginx/sbin/nginx -s stop # 停止 Nginx 常用指令说明main全局配置 nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。 woker_processes 4 在配置文件的顶级main部分，worker角色的工作进程的个数，master进程是接收并分配请求给worker处理。这个数值简单一点可以设置为cpu的核数(grep ^processor /proc/cpuinfo | wc -l)，也是 auto 值，如果开启了ssl和gzip更应该设置成与逻辑CPU数量一样甚至为2倍，可以减少I/O操作。如果nginx服务器还有其它服务，可以考虑适当减少。 worker_cpu_affinity 也是写在main部分。在高并发情况下，通过设置cpu粘性来降低由于多CPU核切换造成的寄存器等现场重建带来的性能损耗。如worker_cpu_affinity 0001 0010 0100 1000; （四核）。 worker_connections 2048 写在events部分。每一个worker进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。nginx作为反向代理服务器，计算公式 最大连接数 = worker_processes * worker_connections/4，所以这里客户端最大连接数是1024，这个可以增到到8192都没关系，看情况而定，但不能超过后面的worker_rlimit_nofile。当nginx作为http服务器时，计算公式里面是除以2。 worker_rlimit_nofile 10240 写在main部分。默认是没有设置，可以限制为操作系统最大的限制65535。 use epoll 写在events部分。在Linux操作系统下，nginx默认使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。在操作系统不支持这些高效模型时才使用select。 http服务器 与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。 sendfile on 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。 keepalive_timeout 65 长连接超时时间，单位是秒，这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。 send_timeout 用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接。 client_max_body_size 10m 允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值 client_body_buffer_size 128k 缓冲区代理缓冲用户端请求的最大字节数 模块http_proxy 这个模块实现的是nginx作为反向代理服务器的功能，包括缓存功能 proxy_connect_timeout 60 nginx跟后端服务器连接超时时间(代理连接超时) proxy_read_timeout 60 连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时) proxy_buffer_size 4k 设置代理服务器（nginx）从后端realserver读取并保存用户头信息的缓冲区大小，默认与proxy_buffers大小相同，其实可以将这个指令值设的小一点 proxy_buffers 4 32k proxy_buffers缓冲区，nginx针对单个连接缓存来自后端realserver的响应，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k 高负荷下缓冲大小（proxy_buffers*2） proxy_max_temp_file_size 当proxy_buffers放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认1024M，它与proxy_cache没有关系。大于这个值，将从upstream服务器传回。设置为0禁用。 proxy_temp_file_write_size 64k 当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。proxy_temp_path（可以在编译的时候）指定写到哪那个目录。 proxy_pass，proxy_redirect见 location 部分。 模块http_gzip gzip on : 开启gzip压缩输出，减少网络传输。 gzip_min_length 1k ： 设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是20。建议设置成大于1k的字节数，小于1k可能会越压越大。 gzip_buffers 4 16k ： 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。 gzip_http_version 1.0 ： 用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。 gzip_comp_level 6 ： gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu) gzip_types ：匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。 gzip_proxied any ： Nginx作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header头。 gzip_vary on ： 和http头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。。 server虚拟主机 http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server。每个server通过监听地址或端口来区分。 listen 监听端口，默认80，小于1024的要以root启动。可以为listen *:80、listen 127.0.0.1:80等形式。 server_name 服务器名，如localhost、www.example.com，可以通过正则匹配。 模块http_stream 这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡，upstream后接负载均衡器的名字，后端realserver以 host:port options; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy_pass 。 location http服务中，某些特定的URL对应的一系列配置项。 root /var/www/html 定义服务器的默认网站根目录位置。如果locationURL匹配的是子目录或文件，root没什么作用，一般放在server指令里面或/下。 index index.jsp index.html index.htm 定义路径下默认访问的文件名，一般跟着root放 proxy_pass http:/backend 请求转向backend定义的服务器列表，即反向代理，对应upstream负载均衡器。也可以proxy_pass http://ip:port。 原文链接 http://www.runoob.com/linux/nginx-install-setup.html https://segmentfault.com/a/1190000002797601#articleHeader7","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"}]},{"title":"Node.js中用escape解决sql注入","date":"2016-07-04T16:00:00.000Z","path":"2016/07/05/Node.js/escape/","text":"直接拼写sql进行数据库的操作时，很容易被人在动态参数中加入特殊字符产生sql注入，威胁数据库的安全。1234567891011121314151617'use strict';const mysql = require('mysql');let param = 'ns';let pool = mysql.createPool(&#123; user: 'root', password: 'root', database: 'nlp_dict'&#125;);pool.getConnection(function (err, conn) &#123; let sql = 'select * from tb_nature where nature = \"' + param + '\" and del_status=1'; conn.query(sql, function (err, result) &#123; console.log(result); &#125;)&#125;); 这时正常情况下能查询到一条数据，如果将param修改成let param = ‘ns”– ‘;sql语句就会变成select * from tb_nature where nature = “ns”– “ and del_status=1后面的del_status就会被参数中的 – 注释掉，失去作用，能查询到多条数据。 如果对param使用escape包装下，就能将参数中的特殊字符进行转义，防止sql的注入。let sql = ‘select * from tb_nature where nature = ‘ + mysql.escape(param) + ‘ and del_status=1’;","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"Android 基础","date":"2016-05-27T16:00:00.000Z","path":"2016/05/28/Android/android-base/","text":"Android 开发的基本环境 JDK (Java Development Kit) IDE (Android Studio) Android SDK (Android Software Development Kit) ADT (Android Development Tools) ADT 和 Android SDK的区别 ADT(Android Development Tools)： 目前Android开发所用的开发工具是Eclipse，在Eclipse编译IDE环境中，安装ADT，为Android开发提供开发工具的升级或者变更，简单理解为在Eclipse下开发工具的升级下载工具。ADT只是一个Eclipse的插件，里面可以设置sdk路径。 SDK(Software Development Kit)： 一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。在Android中，他为开发者提供了库文件以及其他开发所用到的工具。简单理解为开发工具包集合，是整体开发中所用到的工具包，如果你不用Eclipse作为你的开发工具，你就不需要下载ADT，只下载SDK即可开发。 JDK 和 JRE的区别 JRE(Java Runtime Environment): 顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。 JDK(Java Development Kit): 顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。 JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。 Android项目目录结构 src 放java代码的目录 gen目录下的文件是编译器生成 assets 资源目录，例如音频、图片、xml（不一定要打入apk包中） bin存放编译后的.class .dex .apk文件的目录，编译器生成 libs放第三方jar包 res资源目录 （都要打入apk包中） drawable（根据名字存放不同分辨率的图片，Android系统为了适配移动设备会根据设备的DPI去对应的目录选择图片） Drawable-hdpi 存放高分辨率图片； Drawable-ldpi 存放低分辨率图片； Drawable-mdpi 存放中分辨率图片； Drawable-xhdpi 存放中高分辨率图片； Drawable-xhdpi 存放特高分辨率图片。 layout 布局文件，Android系统为了使控制层和View层做分离，对一些静态的界面尽量写成xml文件的形式放在Layout文件夹下。 menu 存放菜单文件 values 存放文字信息配置 dimens.xml文件存放一些尺寸信息，为了适配屏幕用； string.xml文件存放文本信息； styles.xml 文件中定义了一些属性集，方便复用和修改。 AndroidManifest.xml 清单文件，这个文件列出了应用程序所提供的功能，需要什么权限，用到那些服务，当前应用的版本，最低支持android版本，应用的名称、图标和包名，有那些组件，每个组件的配置信息","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"}]},{"title":"mysql 批量删除错误分析","date":"2016-05-25T16:00:00.000Z","path":"2016/05/26/MySQL/mysql-batch-delete/","text":"1234delete t1 from tb_dict t1 where t1.id in ( select t2.id from tb_dict t2 where t2.nature = 'v-taxi'); 使用这条 sql 语句进行批量删除时报 “You can’t specify target table ‘t1’ for update in FROM clause” 错误，查询后得知原来 msyql 不允许在子查询的同时删除原表中的数据。下面对应的解决办法。 123456delete t1 from tb_dict t1 where t1.id in ( select t3.id from ( select * from tb_dict t2 where t2.nature = 'v-taxi' ) as t3); 将子查询得到的数据封装成临时表，这时就能解决问题了。","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"sql 操作","date":"2016-05-25T16:00:00.000Z","path":"2016/05/26/MySQL/sql/","text":"删除重复的数据 1234567delete a from tb_dict awhere (a.keyword,a.nature) in ( select * from (select keyword,nature from tb_dict group by keyword, nature having count(*) &gt; 1) b) and a.id not in ( select * from (select min(id) from tb_dict group by keyword, nature having count(*)&gt;1) c) 查询重复的数据 1234select * from tb_dict a where (a.keyword,a.nature, a.freq) in ( select keyword,nature, freq from tb_dict group by keyword, nature, freq having count(*) &gt; 1)","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"List 进行 remove 操作时抛出 java.lang.UnsupportedOperationException 异常分析","date":"2016-05-12T16:00:00.000Z","path":"2016/05/13/Java/UnsupportedOperationException/","text":"今天将一个数组转换成 List 然后进行 remove 操作时却抛出 java.lang.UnsupportedOperationException 异常。 1234567891011121314String pattern = \" ^, v, m, n-music-name, $ \";String[] patternSplit = Utils.getStringTrimSplit(pattern, \",\");// 去除模式中的^和$标识List&lt;String&gt; natureList = Arrays.asList(patternSplit);if (\"^\".equals(natureList.get(0))) &#123; natureList.remove(0); // throw java.lang.UnsupportedOperationException&#125;if (\"$\".equals(natureList.get(natureList.size() - 1))) &#123; natureList.remove(natureList.size() - 1); // throw java.lang.UnsupportedOperationException&#125;String[] natureArray = natureList.toArray(new String[natureList.size()]);System.out.println(natureArray.length); 看了下源码才发现使用 Arrays.asList(arr) 转换的 List 并不能进行 add 和 remove 操作。Arrays.asList(arr) 返回的类型是 Aarrays$ArrayList 并不是 ArrayList，Aarrays$ArrayList 和 ArrayList 都继承 AbstractList，但是 AbstractList 中的 add 方法和 remove 方法都是直接抛出 UnsupportedOperationException，并没有直接实现。ArrayList 重写了 add 方法和 remove 方法,能够进行对应的添加和删除操作，Aarrays$ArrayList 却没有去重写，所以此时调用 add 方法和 remove 方法会抛出 UnsupportedOperationException。 解决办法1234// oldList&lt;String&gt; natureList = Arrays.asList(patternSplit);// new List&lt;String&gt; natureList = new ArrayList&lt;&gt;(Arrays.asList(patternSplit)); 源码Arrays.asList(arr) 返回 Aarrays$ArrayList ， Aarrays$ArrayList 继承 AbstractListArrayList 继承 AbstractListAbstractList 中的 add 方法和 remove 方法都直接抛出 UnsupportedOperationExceptionArrayList 重写 add 方法和 remove 方法","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]},{"title":"缓存的相关概念和应用","date":"2016-05-10T16:00:00.000Z","path":"2016/05/11/Architecture/cache/","text":"一般都是用Redis或者Memcached来做数据的缓存，让程序的读取效率更高，以此缓解数据库的压力。 缓存穿透原因：我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 解决办法：可以在查询时将不存在的key预先设定一个值。比如，”key” , “&amp;&amp;”。在返回这个&amp;&amp;值的时候，我们的应用就可以认为这是不存在的key，再次请求这个key，如果取到的值不再是&amp;&amp;，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。 缓存并发原因：有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。 解决办法：对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。 缓存失效原因：高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。 解决办法：将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 总结缓存并发和缓存失效都是在高并发的时候对压力的优化，缓存穿透很有必要在做缓存的时候加上解决的措施。 原文链接：缓存穿透、缓存并发、缓存失效之思路变迁 - 小程故事多","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"}]},{"title":"We have a problem with promises","date":"2016-02-22T16:00:00.000Z","path":"2016/02/23/JavaScript/promises/","text":"下面的四种 promises 的区别是什么1234567891011doSomething().then(function () &#123; return doSomethingElse(); &#125;); doSomething().then(function () &#123; doSomethingElse(); &#125;); doSomething().then(doSomethingElse()); doSomething().then(doSomethingElse); 原文地址链接：http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/Puzzle #1 123456doSomething|-----------------| doSomethingElse(undefined) |------------------| finalHandler(resultOfDoSomethingElse) |------------------| Puzzle #2 123456doSomething|-----------------| doSomethingElse(undefined) |------------------| finalHandler(undefined) |------------------| Puzzle #3 123456doSomething|-----------------|doSomethingElse(undefined)|---------------------------------| finalHandler(resultOfDoSomething) |------------------| Puzzle #4 123456doSomething|-----------------| doSomethingElse(resultOfDoSomething) |------------------| finalHandler(resultOfDoSomethingElse) |------------------| Promises 解决了 Callback Hell 问题，并且不仅仅是缩进问题。就像在 《Callback Hell 的救赎》 中描述的一样，回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。 Promises的正确的风格123456789remotedb.allDocs(...).then(function (resultOfAllDocs) &#123; return localdb.put(...);&#125;).then(function (resultOfPut) &#123; return localdb.get(...);&#125;).then(function (resultOfGet) &#123; return localdb.put(...);&#125;).catch(function (err) &#123; console.log(err);&#125;); 这种写法被称为 composing promises ，是 promises 的强大能力之一。每一个函数只会在前一个 promise 被调用并且完成回调后调用，并且这个函数会被前一个 promise 的输出调用 用了 promises 后怎么用 forEach?1234567891011121314151617// 错误写法// I want to remove() all docsdb.allDocs(&#123;include_docs: true&#125;).then(function (result) &#123; result.rows.forEach(function (row) &#123; db.remove(row.doc); &#125;);&#125;).then(function () &#123; // I naively believe all docs have been removed() now!&#125;);// 正确写法db.allDocs(&#123;include_docs: true&#125;).then(function (result) &#123; return Promise.all(result.rows.map(function (row) &#123; return db.remove(row.doc); &#125;));&#125;).then(function (arrayOfResults) &#123; // All docs have really been removed() now!&#125;); 一定不要忘记使用 .catch() catch() 与 then(null, …) 并非完全等价catch() 仅仅是一个语法糖。因此下面两段代码是等价的: 123456somePromise().catch(function (err) &#123; // handle error&#125;);somePromise().then(null, function (err) &#123; // handle error&#125;); 但是并非完全等价 1234567891011somePromise().then(function () &#123; throw new Error('oh noes');&#125;).catch(function (err) &#123; // I caught your error! :)&#125;);somePromise().then(function () &#123; throw new Error('oh noes');&#125;, function (err) &#123; // I didn't catch your error! :(&#125;);","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"}]},{"title":"深入浅出ES6笔记","date":"2016-02-17T16:00:00.000Z","path":"2016/02/18/JavaScript/ES6-in-depth/","text":"ES6 是什么 编程语言 JavaScript 是 ECMAScript 的实现和扩展,由 ECMA(一个类似 W3C 的标准组织)参与进行标准化。 ES4 饱受争议,当标准委员会最终停止开发 ES4 时,其成员同意发布一个相对谦和的 ES5 版本,随后继续制定一些更具实质性的新特性。这一明确的协商协议最终命 名为“Harmony”(ES6)。 2009 年发布的改进版本 ES5,引入了 Object.create()、Object.defineProperty()、getters 和 setters、严格模式以及 JSON 对象。 如果你想在 web 环境中使用这种新语法,同时需要支持 IE 和 Safari, 你可以使用 Babel 或 Google 的 Traceur 这些编译器来将你的 ES6 代码翻译为 Web 友好 的 ES5 代码。 迭代器和 for-of 循环遍历数组中的元素 20 年前 JavaScript 刚萌生时 for (var index = 0; index &lt; myArray.length; index++) { console.log(myArray[index]); } ES5 正式发布后 myArray.forEach(function (value) { console.log(value); }); 这段代码看起来更加简洁,但这种方法也有一个小缺陷:你不能使用 break 语句中 断循环,也不能使用 return 语句返回到外层函数。 for-in 循环(千万别这样做, 是为普通对象设计的) for (var index in myArray) { console.log(myArray[index]); } 在这段代码中,赋给index的值不是实际的数字,而是字符串“0”、“1”、“2”, 此时很可能在无意之间进行字符串算数计算,例如:“2” + 1 == “21”,这给 编码过程带来极大的不便。 作用于数组的 for-in 循环体除了遍历数组元素外,还会遍历自定义属性。举个例子,如果你的数组中有一个可枚举属性 myArray.name,循环将额外执行 一次,遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。 最让人震惊的是,在某些情况下,这段代码可能按照随机顺序遍历数组元素。 简而言之,for-in 是为普通对象设计的,你可以遍历得到字符串类型的键,因此不适用于数组遍历。 ES6 for (var value of myArray) { console.log(value); } for-in 循环用来遍历对象属性。 for-of 循环用来遍历数据—例如数组中的值。 for-of 循环for (var value of myArray) { console.log(value); } 这是最简洁、最直接的遍历数组元素的语法这个方法避开了 for-in 循环的所有缺陷与 forEach()不同的是,它可以正确响应 break、continue 和 return 语句for-of 循环不仅支持数组,还支持大多数类数组对象,例如 DOM NodeList 对象。for-of 循环也支持字符串遍历,它将字符串视为一系列的 Unicode 字符来进行遍历 var str = &apos;liuhaiming&apos;; for(var chr of str) { console.log(chr); } for-of 循环也支持Set 对象 var uniqueWords = new Set(words); for (var word of uniqueWords) { console.log(word); } for-of 循环也支持Map对象 for (var [key, value] of phoneBookMap) { console.log(key + &quot;&apos;s phone number is: &quot; + value); } for-of 循环不支持普通对象,但如果你想迭代一个对象的属性,你可以用 for-in 循 环(这也是它的本职工作)或内建的 Object.keys()方法: // 向控制台输出对象的可枚举属性 for (var key of Object.keys(someObject)) { console.log(key + &quot;: &quot; + someObject[key]); }","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"},{"name":"es6","slug":"es6","permalink":"http://haiyue.me/tags/es6/"}]},{"title":"三亚春节","date":"2016-02-15T16:00:00.000Z","path":"2016/02/16/Photo/sanyacunjie/","text":"在三亚过的春节，也没怎么出去玩……","tags":[]},{"title":"ES6-Class基本语法","date":"2016-02-01T16:00:00.000Z","path":"2016/02/02/JavaScript/es6-class/","text":"Class基本语法ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。​ // old function Point(x,y){ this.x = x; this.y = y; } Point.prototype.toString = function () { return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’; } // new class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’; } } Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个保留字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。类的内部所有定义的方法，都是不可枚举的（enumerable）。这一点与ES5的行为不一致。 class Point { constructor(x, y) {} toString() {} } Object.keys(Point.prototype) // [] Object.getOwnPropertyNames(Point.prototype) // [&quot;constructor&quot;,&quot;toString&quot;] constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 class Foo { constructor() { return Object.create(null); } } new Foo() instanceof Foo; // false 生成实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）与ES5一样，类的所有实例共享一个原型对象。所以proto属性是相等的。name属性总是返回紧跟在class关键字后面的类名。 class Point {} Point.name // &quot;Point&quot; 下面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 const MyClass = class Me { getClassName() { return Me.name; } }; 如果Class内部没用到的话，可以省略Me。采用Class表达式，可以写出立即执行的Class。Class不存在变量提升（hoist），这一点与ES5完全不同。 new Foo(); // ReferenceError class Foo {} 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。 Class的继承Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 class ColorPoint extends Point {} 下面代码中，constructor方法和toString方法之中，都出现了super关键字，它指代父类的实例（即父类的this对象）。 class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + &apos; &apos; + super.toString(); // 调用父类的toString() } } 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。 class MyArray extends Array { constructor(...args) { super(...args); } } var arr = new MyArray(); arr[0] = 12; arr.length // 1 arr.length = 0; arr[0] // undefined Class的取值函数（getter）和存值函数（setter）与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 class MyClass { constructor() { // ... } get prop() { return &apos;getter&apos;; } set prop(value) { console.log(&apos;setter: &apos;+value); } } let inst = new MyClass(); inst.prop = 123; // setter: 123 inst.prop // &apos;getter&apos; Class的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 class Foo { static classMethod() { return &apos;hello&apos;; } } Foo.classMethod() // &apos;hello&apos; var foo = new Foo(); foo.classMethod() // TypeError: undefined is not a function 父类的静态方法，可以被子类继承。静态方法也是可以从super对象上调用的。 Class的静态属性静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。 class Foo { } Foo.prop = 1; Foo.prop // 1 目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。 new.target属性new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 function Person(name) { if (new.target !== undefined) { this.name = name; } else { throw new Error(&apos;必须使用new生成实例&apos;); } } // 另一种写法 function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error(&apos;必须使用new生成实例&apos;); } } var person = new Person(&apos;张三&apos;); // 正确 var notAPerson = Person.call(person, &apos;张三&apos;); // 报错 Class内部调用new.target，返回当前Class。子类继承父类时，new.target会返回子类。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); // ... } } class Square extends Rectangle { constructor(length) { super(length, length); } } var obj = new Square(3); // 输出 false 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 类的修饰修饰器（Decorator）是一个表达式，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。​读阮一峰老师《ECMAScript6入门》一书的笔记","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"},{"name":"es6","slug":"es6","permalink":"http://haiyue.me/tags/es6/"}]},{"title":"ES6-Module","date":"2016-02-01T16:00:00.000Z","path":"2016/02/02/JavaScript/es6-style/","text":"规格文件规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。 编程风格块级作用域let取代var全局常量和线程安全在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算。 // bad var a = 1, b = 2, c = 3; // good const a = 1; const b = 2; const c = 3; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。所有的函数都应该设置为常量。 严格模式V8引擎只在严格模式之下，支持let。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 // bad const a = &quot;foobar&quot;; const b = &apos;foo&apos; + a + &apos;bar&apos;; // good const a = &apos;foobar&apos;; const b = `foo${a}bar`; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 const arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; } // best function getFullName({ firstName, lastName }) { } 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 // bad function processInput(input) { return [left, right, top, bottom]; } // good function processInput(input) { return { left, right, top, bottom }; } const { left, right } = processInput(input); 数组使用扩展运算符（…）拷贝数组。 // bad const len = items.length; const itemsCopy = []; for (let i = 0; i &lt; len; i++) { itemsCopy[i] = items[i]; } // good const itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。 const foo = document.querySelectorAll(&apos;.foo&apos;); const nodes = Array.from(foo); 立即执行函数可以写成箭头函数的形式。 (() =&gt; { console.log(&apos;Welcome to the Internet.&apos;); })(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 // bad [1, 2, 3].map(function (x) { return x * x; }); // best [1, 2, 3].map(x =&gt; x * x); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;); } // good function concatenateAll(...args) { return args.join(&apos;&apos;); } 使用默认值语法设置函数参数的默认值。 // bad function handleThings(opts) { opts = opts || {}; } // good function handleThings(opts = {}) { // ... } 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 // bad function divide(a, b, option = false ) { } // good function divide(a, b, { option = false } = {}) { } Map结构注意区分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。 let map = new Map(arr); for (let key of map.keys()) { console.log(key); } for (let value of map.values()) { console.log(value); } for (let item of map.entries()) { console.log(item[0], item[1]); } Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 // bad function Queue(contents = []) { this._queue = [...contents]; } Queue.prototype.pop = function() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } // good class Queue { constructor(contents = []) { this._queue = [...contents]; } pop() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } } 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 // bad const inherits = require(&apos;inherits&apos;); function PeekableQueue(contents) { Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function() { return this._queue[0]; } // good class PeekableQueue extends Queue { peek() { return this._queue[0]; } } 模块Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 // bad const moduleA = require(&apos;moduleA&apos;); const func1 = moduleA.func1; const func2 = moduleA.func2; // good import { func1, func2 } from &apos;moduleA&apos;; 使用export取代module.exports。如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。 // commonJS的写法 var React = require(&apos;react&apos;); var Breadcrumbs = React.createClass({ render() { return &lt;nav /&gt;; } }); module.exports = Breadcrumbs; // ES6的写法 import React from &apos;react&apos;; const Breadcrumbs = React.createClass({ render() { return &lt;nav /&gt;; } }); export default Breadcrumbs 如果模块默认输出一个函数，函数名的首字母应该小写。 function makeStyleGuide() { } export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 const StyleGuide = { es6: { } }; export default StyleGuide; 读阮一峰老师《ECMAScript6入门》一书的笔记","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"},{"name":"es6","slug":"es6","permalink":"http://haiyue.me/tags/es6/"}]},{"title":"ES6-Module","date":"2016-02-01T16:00:00.000Z","path":"2016/02/02/JavaScript/es6-module/","text":"ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 // CommonJS模块 let { stat, exists, readFile } = require(&apos;fs&apos;); 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 // ES6模块 import { stat, exists, readFile } from &apos;fs&apos;; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。 严格模式(ES5引入)ES6的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。 export命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。 // good export var firstName = &apos;Michael&apos;; export var lastName = &apos;Jackson&apos;; // best var firstName = &apos;Michael&apos;; var lastName = &apos;Jackson&apos;; export {firstName, lastName}; export命令除了输出变量，还可以输出函数或类（class）。 function v1() { ... } function v2() { ... } export { v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion }; export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下面的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。export语句输出的值是动态绑定，绑定其所在的模块。 export var foo = &apos;bar&apos;; setTimeout(() =&gt; foo = &apos;baz&apos;, 500); 上面代码输出变量foo，值为bar，500毫秒之后变成baz。 import命令使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。 import {firstName, lastName, year} from &apos;./profile&apos;; import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 import { lastName as surname } from &apos;./profile&apos;; import命令具有提升效果，会提升到整个模块的头部，首先执行。 foo(); import { foo } from &apos;my_module&apos;; 如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 export { es6 as default } from &apos;./someModule&apos;; // 等同于 (best) import { es6 } from &apos;./someModule&apos;; export default es6; 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 import * as circle from &apos;./circle&apos;; console.log(&quot;圆面积：&quot; \\+ circle.area(4)); console.log(&quot;圆周长：&quot; \\+ circle.circumference(14)); export default命令export default命令，为模块指定默认输出。一个模块只能有一个默认输出，因此export deault命令只能使用一次。 export default function () { console.log(&apos;foo&apos;); } 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。这时import命令后面，不使用大括号。 import customName from &apos;./export-default&apos;; customName(); // &apos;foo&apos; export default命令用在非匿名函数前，也是可以的。加载的时候，视同匿名函数加载。如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。 import customName, { otherMethod } from &apos;./export-default&apos;; 模块的继承export * from &apos;circle&apos;; export var e = 2.71828182846; export default function(x) { return Math.exp(x); } 上面代码中的export ，表示再输出circle模块的所有属性和方法。注意，export 命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 ES6模块加载的实质ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。而ES6模块输出的是值的引,用此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。。由于ES6输入的模块变量，只是一个”符号连接“，所以这个变量是只读的，对它进行重新赋值会报错。 ES6模块的循环加载ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，遇到模块加载命令import时，不会去执行模块，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 ES6模块的转码浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。除了Babel可以用来转码之外，还有以下两个方法，也可以用来转码。 ES6 module transpiler SystemJS 读阮一峰老师《ECMAScript6入门》一书的笔记","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"},{"name":"es6","slug":"es6","permalink":"http://haiyue.me/tags/es6/"}]},{"title":"蓝色港湾跨年夜","date":"2016-01-05T16:00:00.000Z","path":"2016/01/06/Photo/lansegangwan/","text":"跨年夜无聊去蓝色港湾看灯展，还是挺好看的。","tags":[]},{"title":"北京大雪","date":"2016-01-05T16:00:00.000Z","path":"2016/01/06/Photo/beijingdaxue/","text":"北京难得一见的大雪，冰天雪地的很好看。","tags":[]},{"title":"ES6-Generator函数","date":"2015-10-27T16:00:00.000Z","path":"2015/10/28/JavaScript/es6-generator/","text":"基本概念Generator函数是ES6提供的一种异步编程解决方案Generator函数有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。调用Generator函数后，该函数并不执行，返回的是一个指向内部状态的指针对象（遍历器对象）。下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。 function* helloWorldGenerator() { yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;; } var hw = helloWorldGenerator(); hw.next() // { value: &apos;hello&apos;, done: false } hw.next() // { value: &apos;world&apos;, done: false } hw.next() // { value: &apos;ending&apos;, done: true } hw.next() // { value: undefined, done: true } 每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 ##yield语句遍历器对象的next方法的运行逻辑如下。 遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。 如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 如果该函数没有return语句，则返回的对象的value属性值为undefined。 yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。yield语句不能用在普通函数中，否则会报错。yield语句如果用在一个表达式之中，必须放在圆括号里面。yield语句用作函数参数或赋值表达式的右边，可以不加括号。 ##next方法的参数yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。 ##for…of循环for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象。for…of循环、扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们可以将Generator函数返回的Iterator对象，作为参数。 function* numbers () { yield 1 yield 2 return 3 yield 4 } [...numbers()] // [1, 2] Array.from(numbers()) // [1, 2] let [x, y] = numbers(); x // 1 y // 2 for (let n of numbers()) { console.log(n) } // 1 // 2 ##Generator.prototype.throw()Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。如果Generator函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。如果Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历，否则遍历直接终止。Generator函数内抛出的错误，也可以被函数体外的catch捕获。 ##Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。 function* gen() { yield 1; yield 2; yield 3; } var g = gen(); g.next() // { value: 1, done: false } g.return(&quot;foo&quot;) // { value: &quot;foo&quot;, done: true } g.next() // { value: undefined, done: true } 如果return方法调用时，不提供参数，则返回值的vaule属性为undefined。如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。 yield*语句yield语句，用来在一个Generator函数里面执行另一个Generator函数。yield语句等同于在Generator函数内部，部署一个for…of循环。如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。 function* gen(){ yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; } gen().next() // { value:&quot;a&quot;, done:false } ##作为对象属性的Generator函数12345let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; 等价于 12345let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;; ##构造函数是Generator函数 // ？ ##Generator函数推导 // ? ##Generator与状态机 // ? ##Generator与协程 // ? ##异步操作的同步化表达Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。 123456789101112function* main() &#123; var result = yield request(&quot;http://some.url&quot;); var resp = JSON.parse(result); console.log(resp.value);&#125;function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;var it = main();it.next(); ##控制流管理 // ??? ##部署iterator接口 // ? ##作为数据结构 // ? 读阮一峰老师《ECMAScript6入门》一书的笔记","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"},{"name":"es6","slug":"es6","permalink":"http://haiyue.me/tags/es6/"}]},{"title":"香山红叶节","date":"2015-10-27T16:00:00.000Z","path":"2015/10/28/Photo/xiangshan/","text":"老早爬起来去香山看红叶，没有想象中的那么好，红叶不多，可能去的还不是时候。","tags":[]},{"title":"ES6-字符串的扩展","date":"2015-10-25T16:00:00.000Z","path":"2015/10/26/JavaScript/es6-string/","text":"##字符的Unicode表示法 之前不识别在“\\u”后面跟上超过0xFFFF的数值（比如\\u20BB7），现在用只要将码点放入大括号中就能识别了（比如\\u{20BB7}） 所以现在JavaScript共有6种方法可以表示一个字符​ ‘\\z’ === ‘z’ // true ‘\\172’ === ‘z’ // true ‘\\x7A’ === ‘z’ // true ‘\\u007A’ === ‘z’ // true ‘\\u{7A}’ === ‘z’ // true ##codePointAt() // ? JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。 var s = &quot;𠮷&quot;; s.length // 2 s.charAt(0) // &apos;&apos; s.charAt(1) // &apos;&apos; s.charCodeAt(0) // 55362 s.charCodeAt(1) // 57271 ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。 ##String.fromCodePoint() ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别辅助平面的字符（编号大于0xFFFF）。 String.fromCharCode(0x20BB7) // &quot;ஷ&quot; ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。 String.fromCodePoint(0x20BB7) // &quot;𠮷&quot; ##字符串的遍历器接口 ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 ##at() // ES7 ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。 ES7提供了字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。 ##normalize() // ? ES6提供String.prototype.normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 ##includes(), startsWith(), endsWith() 传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 这三个方法都支持第二个参数，endsWith的第二个参数表示它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 var s = &apos;Hello world!&apos;; s.startsWith(&apos;world&apos;, 6) // true s.endsWith(&apos;Hello&apos;, 5) // true s.includes(&apos;Hello&apos;, 6) // false ##repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。 &apos;hello&apos;.repeat(2) // &quot;hellohello&quot; &apos;na&apos;.repeat(0) // &quot;&quot; 参数如果是小数，会被取整。 如果repeat的参数是负数或者Infinity，会报错。 但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。 参数NaN等同于0。 如果repeat的参数是字符串，则会先转换成数字。 ##模板字符串 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 模板字符串中嵌入变量，需要将变量名写在${}之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 模板字符串之中还能调用函数。 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。 ##标签模板 模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，其他参数，都是模板字符串各个变量被替换后的值。​ var a = 5; var b = 10; function tag(s, v1, v2) { console.log(s[0]); // “Hello “ console.log(s[1]); // “ world “ console.log(s[2]); // “” console.log(v1); // 15 console.log(v2); // 50 return “OK”; } tagHello ${ a + b } world ${ a * b}; // “OK” 等同于 tag([‘Hello ‘, ‘ world ‘, ‘’], 15, 50) “标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。 var message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`; function SaferHTML(templateData) { var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) { var arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;).replace(/&lt;/g, &quot;&amp;lt;&quot;).replace(/&gt;/g, &quot;&amp;gt;&quot;); // Don&apos;t escape special characters in the template. s += templateData[i]; } return s; } 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。该数组的成员与strings数组完全一致。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将\\n视为\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。 ##String.raw() String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 String.raw`Hi\\n${2+3}!`; // &quot;Hi\\\\n5!&quot; String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。 String.raw({ raw: &apos;test&apos; }, 0, 1, 2); // &apos;t0e1s2t&apos;, 等同于 String.raw({ raw: [&apos;t&apos;,&apos;e&apos;,&apos;s&apos;,&apos;t&apos;] }, 0, 1, 2); 读阮一峰老师《ECMAScript6入门》一书的笔记","tags":[{"name":"note","slug":"note","permalink":"http://haiyue.me/tags/note/"},{"name":"es6","slug":"es6","permalink":"http://haiyue.me/tags/es6/"}]},{"title":"iTerm2的使用","date":"2015-07-22T16:00:00.000Z","path":"2015/07/23/Linux/iterm2/","text":"自从换了mac后连接远程linux服务器一直用电脑自带的终端，每次都要输密码，烦死了。看同事用iTerm挺方便的，就自己也弄了一个。 下载地址http://www.iterm2.com/ 记住远程服务器密码12345set timeout 30spawn ssh liuhaiming@122.92.222.122 -p51618expect &quot;*password*&quot;send “**********\\n&quot;interact 替换图标原图标看着不好看,替换一个喜欢的图标找好自己要替换的图标https://dribbble.com/shots/656627-Terminal-Macintosh-Icon找到自己要替换图标的app右键显示简介，复制下载好的图标，并选中要替换的图标 command + v 就替换好了 换个自己喜欢的主题http://iterm2colorschemes.com/ 相关命令command + O: 打开配置方便选择","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"},{"name":"软件","slug":"软件","permalink":"http://haiyue.me/tags/软件/"}]},{"title":"setImmediate,setTimeout,nextTick的区别是什么","date":"2015-07-21T16:00:00.000Z","path":"2015/07/22/JavaScript/nexttick_immediate/","text":"区别1、nextTick和setImmediate主要的区别在于任务插入的位置nextTick的插入位置是在当前帧的末尾、io回调之前，如果nextTick过多，会导致io回调不断延后setImmediate的插入位置是在下一帧，不会影响io回调。 2、Nodejs的特点是事件驱动，异步I/O产生的高并发，产生此特点的引擎是事件循环，事件被分门别类地归到对应的事件观察者上，比如idle观察者，定时器观察者，I/O观察者等等，事件循环每次循环称为Tick，每次Tick按照先后顺序从事件观察者中取出事件进行处理。调用setTimeout()时创建的计时器会被放入定时器观察者内部的红黑树中，每次Tick时，会从该红黑树中检查定时器是否超过定时时间，超过的话，就立即执行对应的回调函数。由于定时器是超时触发，这会导致触发精确度降低。 代码例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function nextTick(msg, cb) &#123; process.nextTick(function() &#123; console.log(&apos;tick: &apos; + msg); if (cb) &#123; cb(); &#125; &#125;);&#125;function immediate(msg, cb) &#123; setImmediate(function() &#123; console.log(&apos;immediate : &apos; + msg); if (cb) &#123; cb(); &#125; &#125;);&#125;nextTick(&apos;1&apos;);nextTick(&apos;2&apos;, function() &#123; nextTick(&apos;10&apos;);&#125;);immediate(&apos;3&apos;, function() &#123; nextTick(&apos;5&apos;);&#125;);nextTick(&apos;7&apos;, function() &#123; immediate(&apos;9&apos;);&#125;);immediate(&apos;4&apos;, function() &#123; nextTick(&apos;8&apos;);&#125;);var n = 0;const timer = setInterval(function() &#123; n++; console.log(&apos;interval:&apos;, n); nextTick(&apos;tick from interval: &apos; + n); nextTick(&apos;another tick from interval: &apos; + n); immediate(&apos;immediate from interval: &apos; + n); immediate(&apos;another immediate from interval: &apos; + n); if ( n === 3 ) &#123; clearInterval(timer); &#125;&#125;, 0);console.log(&apos;the last line of the program.&apos;); 结果12345678910111213141516171819202122232425the last line of the program.tick: 1tick: 2tick: 7tick: 10interval: 1tick: tick from interval: 1tick: another tick from interval: 1immediate : 3immediate : 4immediate : 9immediate : immediate from interval: 1immediate : another immediate from interval: 1tick: 5tick: 8interval: 2tick: tick from interval: 2tick: another tick from interval: 2immediate : immediate from interval: 2immediate : another immediate from interval: 2interval: 3tick: tick from interval: 3tick: another tick from interval: 3immediate : immediate from interval: 3immediate : another immediate from interval: 3 Maximum call stack size exceeded错误的原因之所以会发生Maximum call stack size exceeded,因为process.maxTickDepth的缺省值是1000，如果递归调用nextTick只能调用1000次，超过1000就会报这个错，但并不是真正栈溢出，只是想给你一个提示不希望你递归调用nextTick太多次，如果nextTick递归调用，那么其他的回调事件就会等待，会造成event loop饥饿，所以官方推荐用setImmediate作为递归调用 资料来源求科普setImmediate APIsetTimeout，setInterval，process.nextTick，setImmediate in Nodejs","tags":[{"name":"original","slug":"original","permalink":"http://haiyue.me/tags/original/"}]}]